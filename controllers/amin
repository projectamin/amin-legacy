#!/usr/bin/perl

#LICENSE:

#Please see the LICENSE file included with this distribution 
#or see the following website http://projectamin.org.

use strict;
use Amin;
use Amin::Controller::CLI;
use Amin::Controller::CLIOutput;
use Amin::Machine::AdminList;
use Amin::Machine::NetworkMap;
use Amin::Machine::AdminList::Name;
use Amin::Machine::Profile::Checker;
use Sort::Naturally;
use Getopt::Long;
use XML::SAX::PurePerl;

my $cli = Amin::Controller::CLI->new();
my $help = (<<END);

amin is a simple Amin controller.

Any uri option can use other uris schemes
than the example http:// ones below. This 
includes uris like https:// file:// or ftp://.
There are other uri schemes accepted, but 
some may have problems... Please see LWP for
full details. 

The controller accepts the -u uri profile option 
with any uri ie http://example.com/profile.xml. 

The controller accepts the -a adminlist option
with any uri ie http://example.com/adminlist.xml

The controller accepts the -p option
with the profile as STDIN, this is usually used
by other scripts. 

The controller accepts the -n networkmap option
with any uri ie http://example.com/networkmap.xml

The networkmap option will apply to any adminlist
or profile(either uri or STDIN). Networkmaps inside
of an adminlist will be processed in addition to 
this networkmap option. 

The controller accepts the -m machine spec option
with any uri ie http://example.com/machine_spec.xml
Changing the machine_spec will alter your machine 
processing. Please see Amin::Machines for more
details. 

The controller accepts the -t machine type option
with one of the available machine types. By default 
Amin has uses the Dispatcher machine type. Please 
see Amin::Machines for more details. 

You may also design your own machines and supply 
their full module names. Please see Amin::Machine 
for more details on building your own machine...

The controller accepts the -x filter parameter option,
which can be passed into the machine, for any processing
by various machine filters

Please perldoc the various Amin modules or visit
the website at http://projectamin.org/ for more information.

In terms of processing order, an adminlist is processed
first, then a profile by uri and finally a profile by STDIN.
You can make your own controller if you are unhappy with this
order.

END

#define help
$cli->help($help);


my $usage = (<<END);
[-h|-help]
[-u|-uri] uri:// 
[-p|-profile] as <STDIN>
[-a|-adminlist] uri://
[-n|-networkmap] uri://
[-m|-machine_spec] uri://
[-x|-filter_param] parameters
[-t|-machine_type] ex. Dispatcher
[-o|-machine_name] ex. Amin::Machine::Dispatcher
[-g|-generator] ex. XML::SAX::PurePerl
[-h|-handler] ex.Amin::Machine::Handler::Writer
[-l|-log] ex. Amin::Machine::Log::Standard
[-v|-version] 
END

$cli->usage($usage);

my $version = "2.0";
$cli->version($version);

#pass the $cli object to get_profile
#this will load up the $cli object with
#all the details from the command line
get_profile($cli);

#the commented out code below is all
#a simple uri based controller needs

#my $amin = Amin->new();
#$amin->parse($cli->{'URI'});

#this controller is a little more advanced.

if (defined $cli->adminlist) {

	
	my $adminlist = $cli->adminlist;
	my @networkmap;
	my @adminlists;
	my @profiles;
	my $simplemap;
	
	my $h = Amin::Machine::AdminList->new();
	my $p = XML::SAX::PurePerl->new(Handler => $h);
	$adminlist = $p->parse_uri($adminlist);
	
	#get/parse/load the adminlist/class map
	#this is used for when people name="" their 
	#adminlists and then use the map to specify
	#which names they want to run.
	my $adminlist_map;
	if($cli->adminlist_map) {
		my $h = Amin::Machine::AdminList::Name->new();
		my $p = XML::SAX::PurePerl->new(Handler => $h);
		$adminlist_map = $p->parse_uri($cli->adminlist_map);
	}
	
	foreach my $key (nsort keys %$adminlist) {
		if (($key =~ m/server/) || ($adminlist_map->{key})) {
			#if ($adminlist->{key}->{type} eq "map") {
				my $n = Amin::Machine::NetworkMap->new();
				my $np = XML::SAX::PurePerl->new(Handler => $n);
				$simplemap = $np->parse_uri($adminlist->{$key});
				foreach my $map (@$simplemap) {
					if ($map eq undef) {
						next;
					} else {
						push @networkmap, $map;
					}
				}
			#}
		}
		if (($key =~ m/profile/) || ($adminlist_map->{key})) {
			#if ($adminlist->{key}->{type} eq "profile") {
				push @profiles, $adminlist->{$key};
		}
		if (($key =~ m/adminlist/) || ($adminlist_map->{key})) {
			#if ($adminlist->{key}->{type} eq "adminlist") {
				push @adminlists, $adminlist->{$key};
			#}
		}
	}
		
	#deal with adminlists within adminlists
	#we have to repeat ourselves for a while....
	foreach (@adminlists) {
		my $ih = Amin::Machine::AdminList->new();
		my $ip = XML::SAX::PurePerl->new(Handler => $ih);
		my $iadminlist = $ip->parse_uri($_);
		
		foreach my $key (nsort keys %$iadminlist) {
			if (($key =~ m/server/) || ($adminlist_map->{key})) {
	#			if ($adminlist->{key}->{type} eq "adminlist") {
					my $n = Amin::Machine::NetworkMap->new();
					my $np = XML::SAX::PurePerl->new(Handler => $n);
					$simplemap = $np->parse_uri($iadminlist->{$key});
					foreach my $map (@$simplemap) {	
						if ($map eq undef) {
							next;
						} else {
							push @networkmap, $map;
						}
					}
	#			}
			}
			if (($key =~ m/profile/) || ($adminlist_map->{key})) {
	#			if ($adminlist->{key}->{type} eq "adminlist") {
					push @profiles, $iadminlist->{$key};
	#			}
			}
			if (($key =~ m/adminlist/) || ($adminlist_map->{key})) {
	#			if ($adminlist->{key}->{type} eq "adminlist") {
					push @adminlists, $iadminlist->{$key};
	#			}
			}
		}
	}
	
	my @results;
	if (@networkmap) {
		foreach my $networkmap (@networkmap) {
			my $protocol = $networkmap->{protocol};
			foreach my $profile (@profiles) {
				if ($profile =~ /^</) {
				#	$mout = $protocol->parse_string($nm->{$networkmap}, $profile, $adminlist_map);
				} else {
				#	$mout = $protocol->parse_uri($nm->{$networkmap}, $profile, $adminlist_map);
				}
			
			
			}
		}
	} else {
		foreach my $profile (@profiles) {
			if ($profile =~ /^</) {
				my $m = Amin->new (
						Machine_Name => $cli->machine_name, 
						Machine_Spec => $cli->machine_spec,
						Generator => $cli->genereator,
						Handler => $cli->hanlder,
						Filter_Param => $cli->filter_param,
						Log => $cli->log
    				);
				my $aout;
				my $lout;
				if ($cli->networkmap) {
					my $h = Amin::Machine::NetworkMap->new();
					my $p = XML::SAX::PurePerl->new(Handler => $h);
					my $nm = $p->parse_string($cli->networkmap);
					foreach my $networkmap (keys %$nm) {
						my $protocol = $nm->{$networkmap}->{protocol};
						$lout = $protocol->parse_string($nm->{$networkmap}, $profile);
					}
				} else {
					$lout = $m->parse_string($profile);
				}
				foreach (@$lout) {
					$aout = $aout . "$_";
				}
				my $h = Amin::Controller::CLIOutput->new();
				my $p = XML::SAX::PurePerl->new(Handler => $h);
				my $text = $p->parse_string($aout);
				print $text;
			} else {
				my $m = Amin->new (
						Machine_Name => $cli->machine_name, 
						Machine_Spec => $cli->machine_spec,
						Generator => $cli->generator,
						Handler => $cli->handler,
						Filter_Param => $cli->filter_param,
						Log => $cli->log
				);
				my $aout;
				my $lout;
				if ($cli->networkmap) {
					my $h = Amin::Machine::NetworkMap->new();
					my $p = XML::SAX::PurePerl->new(Handler => $h);
					my $nm = $p->parse_uri($cli->networkmap);
					foreach my $networkmap (keys %$nm) {
						my $protocol = $nm->{$networkmap}->{protocol};
						$lout = $protocol->parse_uri($nm->{$networkmap}, $profile);
					}
				} else {
					$lout = $m->parse_uri($profile);
				}
				foreach (@$lout) {
					$aout = $aout . "$_";
				}
				my $h = Amin::Controller::CLIOutput->new();
				my $p = XML::SAX::PurePerl->new(Handler => $h);
				my $text = $p->parse_string($aout);
				print $text;
			}
		}
	}	
	
} elsif (defined $cli->uri) {
	my $m = Amin->new (
				Machine_Name => $cli->machine_name, 
				Machine_Spec => $cli->machine_spec,
				Generator => $cli->generator,
				Handler => $cli->handler,
				Filter_Param => $cli->filter_param,
				Log => $cli->log
    	);
	my $aout;
	my $lout;
	if ($cli->networkmap) {
		my $h = Amin::Machine::NetworkMap->new();
		my $p = XML::SAX::PurePerl->new(Handler => $h);
		my $nm = $p->parse_uri($cli->networkmap);
		foreach my $networkmap (keys %$nm) {
			my $protocol = $nm->{$networkmap}->{protocol};
			$lout = $protocol->parse_uri($nm->{$networkmap}, $cli->uri);
		}
	} else {
		$lout = $m->parse_uri($cli->uri);
	}
	foreach (@$lout) {
		$aout = $aout . "$_";
	}
	my $h = Amin::Controller::CLIOutput->new();
	my $p = XML::SAX::PurePerl->new(Handler => $h);
	my $text = $p->parse_string($aout);
	print $text;
} elsif (defined $cli->profile) {
	my $m = Amin->new (
				Machine_Name => $cli->machine_name, 
				Machine_Spec => $cli->machine_spec,
				Generator => $cli->generator,
				Handler => $cli->handler,
				Filter_Param => $cli->filter_param,
				Log => $cli->log
    	);
	my $aout;
	my $lout;
	if ($cli->networkmap) {
		my $h = Amin::Machine::NetworkMap->new();
		my $p = XML::SAX::PurePerl->new(Handler => $h);
		my $nm = $p->parse_string($cli->networkmap);
		foreach my $networkmap (keys %$nm) {
			my $protocol = $nm->{$networkmap}->{protocol};
			$lout = $protocol->parse_string($nm->{$networkmap}, $cli->profile);
		}
	} else {
		$lout = $m->parse_string($cli->profile);
	}
	foreach (@$lout) {
		$aout = $aout . "$_";
	}
	my $h = Amin::Controller::CLIOutput->new();
	my $p = XML::SAX::PurePerl->new(Handler => $h);
	my $text = $p->parse_string($aout);
	print $text;
} else {
	print "nothing to parse\n";
}

sub get_profile {
	my $cli = shift;
        my ($help, $uri, $profile, $adminlist, $networkmap, 
	    $machine_spec, $machine_type, $machine_name, $generator, $handler, $log, $filter_param, $version, $type, $adminlist_map);
	my $opts_ok = &GetOptions( "h|help"    => \$help,
				   "u|uri=s"     => \$uri,
				   "p|profile=s" => \$profile,
				   "a|adminlist=s" => \$adminlist,
				   "b|adminlist_map=s" => \$adminlist_map,
				   "n|networkmap=s" => \$networkmap,
				   "m|machine_spec=s" => \$machine_spec,
				   "o|machine_name=s" => \$machine_name,
				   "g|generator=s" => \$generator,
				   "h|handler=s" => \$handler,
				   "l|log=s" => \$log,
				   "x|filter_param=s" => \$filter_param,
				   "t|machine_type=s" => \$type,
				   "v|version" => \$version,
	);
        if ( $help ) {
                $cli->print_help();
                exit 1;
        }
	if ($uri) {
		$cli->uri($uri);
	} 
	if ($profile) {
		$cli->profile($profile);
	} 
	if ($adminlist) {
		$cli->adminlist($adminlist);
	} 
	if ($adminlist_map) {
		$cli->adminlist_map($adminlist_map);
	} 
	if ($networkmap) {
		$cli->networkmap($networkmap);
	}
	if ($machine_spec) {
		$cli->machine_spec($machine_spec);
	} 
	if ($filter_param) {
		$cli->filter_param($filter_param);
	} 
	if ($machine_type) {
		$cli->machine_type($machine_type);
	} 
	if ($machine_name) {
		$cli->machine_name($machine_name);
	} 
	if ($generator) {
		$cli->generator($generator);
	} 
	if ($handler) {
		$cli->handler($handler);
	} 
	if ($log) {
		$cli->log($log);
	} 
	if ($version) {
		$cli->print_version();
                exit 1;
	} 
        if (!$opts_ok) {
                $cli->print_usage();
                exit 1;
        };
	if ((!$uri) && (!$profile) && (!$adminlist) && 
	    (!$networkmap) && (!$version) && (!$help)) {	
		$cli->print_usage();
		exit  1;
	}
}

1;

